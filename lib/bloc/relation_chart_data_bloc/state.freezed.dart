// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$RelationChartDataState {
  RelationChartDataModel get relationChartData =>
      throw _privateConstructorUsedError;
  Map<String, LabelData> get classMap => throw _privateConstructorUsedError;
  Map<int, Node> get nodeMap => throw _privateConstructorUsedError;
  Map<int, Relation> get relationMap => throw _privateConstructorUsedError;
  Map<String, bool> get classVisibilityMap =>
      throw _privateConstructorUsedError;
  Map<String, List<Node>> get nodeToClassMap =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $RelationChartDataStateCopyWith<RelationChartDataState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RelationChartDataStateCopyWith<$Res> {
  factory $RelationChartDataStateCopyWith(RelationChartDataState value,
          $Res Function(RelationChartDataState) then) =
      _$RelationChartDataStateCopyWithImpl<$Res, RelationChartDataState>;
  @useResult
  $Res call(
      {RelationChartDataModel relationChartData,
      Map<String, LabelData> classMap,
      Map<int, Node> nodeMap,
      Map<int, Relation> relationMap,
      Map<String, bool> classVisibilityMap,
      Map<String, List<Node>> nodeToClassMap});

  $RelationChartDataModelCopyWith<$Res> get relationChartData;
}

/// @nodoc
class _$RelationChartDataStateCopyWithImpl<$Res,
        $Val extends RelationChartDataState>
    implements $RelationChartDataStateCopyWith<$Res> {
  _$RelationChartDataStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? relationChartData = null,
    Object? classMap = null,
    Object? nodeMap = null,
    Object? relationMap = null,
    Object? classVisibilityMap = null,
    Object? nodeToClassMap = null,
  }) {
    return _then(_value.copyWith(
      relationChartData: null == relationChartData
          ? _value.relationChartData
          : relationChartData // ignore: cast_nullable_to_non_nullable
              as RelationChartDataModel,
      classMap: null == classMap
          ? _value.classMap
          : classMap // ignore: cast_nullable_to_non_nullable
              as Map<String, LabelData>,
      nodeMap: null == nodeMap
          ? _value.nodeMap
          : nodeMap // ignore: cast_nullable_to_non_nullable
              as Map<int, Node>,
      relationMap: null == relationMap
          ? _value.relationMap
          : relationMap // ignore: cast_nullable_to_non_nullable
              as Map<int, Relation>,
      classVisibilityMap: null == classVisibilityMap
          ? _value.classVisibilityMap
          : classVisibilityMap // ignore: cast_nullable_to_non_nullable
              as Map<String, bool>,
      nodeToClassMap: null == nodeToClassMap
          ? _value.nodeToClassMap
          : nodeToClassMap // ignore: cast_nullable_to_non_nullable
              as Map<String, List<Node>>,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RelationChartDataModelCopyWith<$Res> get relationChartData {
    return $RelationChartDataModelCopyWith<$Res>(_value.relationChartData,
        (value) {
      return _then(_value.copyWith(relationChartData: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RelationChartDataStateImplCopyWith<$Res>
    implements $RelationChartDataStateCopyWith<$Res> {
  factory _$$RelationChartDataStateImplCopyWith(
          _$RelationChartDataStateImpl value,
          $Res Function(_$RelationChartDataStateImpl) then) =
      __$$RelationChartDataStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {RelationChartDataModel relationChartData,
      Map<String, LabelData> classMap,
      Map<int, Node> nodeMap,
      Map<int, Relation> relationMap,
      Map<String, bool> classVisibilityMap,
      Map<String, List<Node>> nodeToClassMap});

  @override
  $RelationChartDataModelCopyWith<$Res> get relationChartData;
}

/// @nodoc
class __$$RelationChartDataStateImplCopyWithImpl<$Res>
    extends _$RelationChartDataStateCopyWithImpl<$Res,
        _$RelationChartDataStateImpl>
    implements _$$RelationChartDataStateImplCopyWith<$Res> {
  __$$RelationChartDataStateImplCopyWithImpl(
      _$RelationChartDataStateImpl _value,
      $Res Function(_$RelationChartDataStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? relationChartData = null,
    Object? classMap = null,
    Object? nodeMap = null,
    Object? relationMap = null,
    Object? classVisibilityMap = null,
    Object? nodeToClassMap = null,
  }) {
    return _then(_$RelationChartDataStateImpl(
      relationChartData: null == relationChartData
          ? _value.relationChartData
          : relationChartData // ignore: cast_nullable_to_non_nullable
              as RelationChartDataModel,
      classMap: null == classMap
          ? _value._classMap
          : classMap // ignore: cast_nullable_to_non_nullable
              as Map<String, LabelData>,
      nodeMap: null == nodeMap
          ? _value._nodeMap
          : nodeMap // ignore: cast_nullable_to_non_nullable
              as Map<int, Node>,
      relationMap: null == relationMap
          ? _value._relationMap
          : relationMap // ignore: cast_nullable_to_non_nullable
              as Map<int, Relation>,
      classVisibilityMap: null == classVisibilityMap
          ? _value._classVisibilityMap
          : classVisibilityMap // ignore: cast_nullable_to_non_nullable
              as Map<String, bool>,
      nodeToClassMap: null == nodeToClassMap
          ? _value._nodeToClassMap
          : nodeToClassMap // ignore: cast_nullable_to_non_nullable
              as Map<String, List<Node>>,
    ));
  }
}

/// @nodoc

class _$RelationChartDataStateImpl implements _RelationChartDataState {
  const _$RelationChartDataStateImpl(
      {required this.relationChartData,
      required final Map<String, LabelData> classMap,
      required final Map<int, Node> nodeMap,
      required final Map<int, Relation> relationMap,
      required final Map<String, bool> classVisibilityMap,
      required final Map<String, List<Node>> nodeToClassMap})
      : _classMap = classMap,
        _nodeMap = nodeMap,
        _relationMap = relationMap,
        _classVisibilityMap = classVisibilityMap,
        _nodeToClassMap = nodeToClassMap;

  @override
  final RelationChartDataModel relationChartData;
  final Map<String, LabelData> _classMap;
  @override
  Map<String, LabelData> get classMap {
    if (_classMap is EqualUnmodifiableMapView) return _classMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_classMap);
  }

  final Map<int, Node> _nodeMap;
  @override
  Map<int, Node> get nodeMap {
    if (_nodeMap is EqualUnmodifiableMapView) return _nodeMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_nodeMap);
  }

  final Map<int, Relation> _relationMap;
  @override
  Map<int, Relation> get relationMap {
    if (_relationMap is EqualUnmodifiableMapView) return _relationMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_relationMap);
  }

  final Map<String, bool> _classVisibilityMap;
  @override
  Map<String, bool> get classVisibilityMap {
    if (_classVisibilityMap is EqualUnmodifiableMapView)
      return _classVisibilityMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_classVisibilityMap);
  }

  final Map<String, List<Node>> _nodeToClassMap;
  @override
  Map<String, List<Node>> get nodeToClassMap {
    if (_nodeToClassMap is EqualUnmodifiableMapView) return _nodeToClassMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_nodeToClassMap);
  }

  @override
  String toString() {
    return 'RelationChartDataState(relationChartData: $relationChartData, classMap: $classMap, nodeMap: $nodeMap, relationMap: $relationMap, classVisibilityMap: $classVisibilityMap, nodeToClassMap: $nodeToClassMap)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RelationChartDataStateImpl &&
            (identical(other.relationChartData, relationChartData) ||
                other.relationChartData == relationChartData) &&
            const DeepCollectionEquality().equals(other._classMap, _classMap) &&
            const DeepCollectionEquality().equals(other._nodeMap, _nodeMap) &&
            const DeepCollectionEquality()
                .equals(other._relationMap, _relationMap) &&
            const DeepCollectionEquality()
                .equals(other._classVisibilityMap, _classVisibilityMap) &&
            const DeepCollectionEquality()
                .equals(other._nodeToClassMap, _nodeToClassMap));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      relationChartData,
      const DeepCollectionEquality().hash(_classMap),
      const DeepCollectionEquality().hash(_nodeMap),
      const DeepCollectionEquality().hash(_relationMap),
      const DeepCollectionEquality().hash(_classVisibilityMap),
      const DeepCollectionEquality().hash(_nodeToClassMap));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RelationChartDataStateImplCopyWith<_$RelationChartDataStateImpl>
      get copyWith => __$$RelationChartDataStateImplCopyWithImpl<
          _$RelationChartDataStateImpl>(this, _$identity);
}

abstract class _RelationChartDataState implements RelationChartDataState {
  const factory _RelationChartDataState(
          {required final RelationChartDataModel relationChartData,
          required final Map<String, LabelData> classMap,
          required final Map<int, Node> nodeMap,
          required final Map<int, Relation> relationMap,
          required final Map<String, bool> classVisibilityMap,
          required final Map<String, List<Node>> nodeToClassMap}) =
      _$RelationChartDataStateImpl;

  @override
  RelationChartDataModel get relationChartData;
  @override
  Map<String, LabelData> get classMap;
  @override
  Map<int, Node> get nodeMap;
  @override
  Map<int, Relation> get relationMap;
  @override
  Map<String, bool> get classVisibilityMap;
  @override
  Map<String, List<Node>> get nodeToClassMap;
  @override
  @JsonKey(ignore: true)
  _$$RelationChartDataStateImplCopyWith<_$RelationChartDataStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}
