// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$RelationChartDataState {
  RelationChartDataModel get relationChartData =>
      throw _privateConstructorUsedError;
  Map<String, LabelData> get labelMap => throw _privateConstructorUsedError;
  Map<int, GraphNode> get nodeMap => throw _privateConstructorUsedError;
  Map<int, GraphEdge> get edgeMap => throw _privateConstructorUsedError;
  Map<String, bool> get labelVisibilityMap =>
      throw _privateConstructorUsedError;
  Map<String, List<GraphNode>> get nodeToLabelMap =>
      throw _privateConstructorUsedError;
  Graph? get graph => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $RelationChartDataStateCopyWith<RelationChartDataState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RelationChartDataStateCopyWith<$Res> {
  factory $RelationChartDataStateCopyWith(RelationChartDataState value,
          $Res Function(RelationChartDataState) then) =
      _$RelationChartDataStateCopyWithImpl<$Res, RelationChartDataState>;
  @useResult
  $Res call(
      {RelationChartDataModel relationChartData,
      Map<String, LabelData> labelMap,
      Map<int, GraphNode> nodeMap,
      Map<int, GraphEdge> edgeMap,
      Map<String, bool> labelVisibilityMap,
      Map<String, List<GraphNode>> nodeToLabelMap,
      Graph? graph});

  $RelationChartDataModelCopyWith<$Res> get relationChartData;
}

/// @nodoc
class _$RelationChartDataStateCopyWithImpl<$Res,
        $Val extends RelationChartDataState>
    implements $RelationChartDataStateCopyWith<$Res> {
  _$RelationChartDataStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? relationChartData = null,
    Object? labelMap = null,
    Object? nodeMap = null,
    Object? edgeMap = null,
    Object? labelVisibilityMap = null,
    Object? nodeToLabelMap = null,
    Object? graph = freezed,
  }) {
    return _then(_value.copyWith(
      relationChartData: null == relationChartData
          ? _value.relationChartData
          : relationChartData // ignore: cast_nullable_to_non_nullable
              as RelationChartDataModel,
      labelMap: null == labelMap
          ? _value.labelMap
          : labelMap // ignore: cast_nullable_to_non_nullable
              as Map<String, LabelData>,
      nodeMap: null == nodeMap
          ? _value.nodeMap
          : nodeMap // ignore: cast_nullable_to_non_nullable
              as Map<int, GraphNode>,
      edgeMap: null == edgeMap
          ? _value.edgeMap
          : edgeMap // ignore: cast_nullable_to_non_nullable
              as Map<int, GraphEdge>,
      labelVisibilityMap: null == labelVisibilityMap
          ? _value.labelVisibilityMap
          : labelVisibilityMap // ignore: cast_nullable_to_non_nullable
              as Map<String, bool>,
      nodeToLabelMap: null == nodeToLabelMap
          ? _value.nodeToLabelMap
          : nodeToLabelMap // ignore: cast_nullable_to_non_nullable
              as Map<String, List<GraphNode>>,
      graph: freezed == graph
          ? _value.graph
          : graph // ignore: cast_nullable_to_non_nullable
              as Graph?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RelationChartDataModelCopyWith<$Res> get relationChartData {
    return $RelationChartDataModelCopyWith<$Res>(_value.relationChartData,
        (value) {
      return _then(_value.copyWith(relationChartData: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RelationChartDataStateImplCopyWith<$Res>
    implements $RelationChartDataStateCopyWith<$Res> {
  factory _$$RelationChartDataStateImplCopyWith(
          _$RelationChartDataStateImpl value,
          $Res Function(_$RelationChartDataStateImpl) then) =
      __$$RelationChartDataStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {RelationChartDataModel relationChartData,
      Map<String, LabelData> labelMap,
      Map<int, GraphNode> nodeMap,
      Map<int, GraphEdge> edgeMap,
      Map<String, bool> labelVisibilityMap,
      Map<String, List<GraphNode>> nodeToLabelMap,
      Graph? graph});

  @override
  $RelationChartDataModelCopyWith<$Res> get relationChartData;
}

/// @nodoc
class __$$RelationChartDataStateImplCopyWithImpl<$Res>
    extends _$RelationChartDataStateCopyWithImpl<$Res,
        _$RelationChartDataStateImpl>
    implements _$$RelationChartDataStateImplCopyWith<$Res> {
  __$$RelationChartDataStateImplCopyWithImpl(
      _$RelationChartDataStateImpl _value,
      $Res Function(_$RelationChartDataStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? relationChartData = null,
    Object? labelMap = null,
    Object? nodeMap = null,
    Object? edgeMap = null,
    Object? labelVisibilityMap = null,
    Object? nodeToLabelMap = null,
    Object? graph = freezed,
  }) {
    return _then(_$RelationChartDataStateImpl(
      relationChartData: null == relationChartData
          ? _value.relationChartData
          : relationChartData // ignore: cast_nullable_to_non_nullable
              as RelationChartDataModel,
      labelMap: null == labelMap
          ? _value._labelMap
          : labelMap // ignore: cast_nullable_to_non_nullable
              as Map<String, LabelData>,
      nodeMap: null == nodeMap
          ? _value._nodeMap
          : nodeMap // ignore: cast_nullable_to_non_nullable
              as Map<int, GraphNode>,
      edgeMap: null == edgeMap
          ? _value._edgeMap
          : edgeMap // ignore: cast_nullable_to_non_nullable
              as Map<int, GraphEdge>,
      labelVisibilityMap: null == labelVisibilityMap
          ? _value._labelVisibilityMap
          : labelVisibilityMap // ignore: cast_nullable_to_non_nullable
              as Map<String, bool>,
      nodeToLabelMap: null == nodeToLabelMap
          ? _value._nodeToLabelMap
          : nodeToLabelMap // ignore: cast_nullable_to_non_nullable
              as Map<String, List<GraphNode>>,
      graph: freezed == graph
          ? _value.graph
          : graph // ignore: cast_nullable_to_non_nullable
              as Graph?,
    ));
  }
}

/// @nodoc

class _$RelationChartDataStateImpl implements _RelationChartDataState {
  const _$RelationChartDataStateImpl(
      {required this.relationChartData,
      required final Map<String, LabelData> labelMap,
      required final Map<int, GraphNode> nodeMap,
      required final Map<int, GraphEdge> edgeMap,
      required final Map<String, bool> labelVisibilityMap,
      required final Map<String, List<GraphNode>> nodeToLabelMap,
      this.graph})
      : _labelMap = labelMap,
        _nodeMap = nodeMap,
        _edgeMap = edgeMap,
        _labelVisibilityMap = labelVisibilityMap,
        _nodeToLabelMap = nodeToLabelMap;

  @override
  final RelationChartDataModel relationChartData;
  final Map<String, LabelData> _labelMap;
  @override
  Map<String, LabelData> get labelMap {
    if (_labelMap is EqualUnmodifiableMapView) return _labelMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_labelMap);
  }

  final Map<int, GraphNode> _nodeMap;
  @override
  Map<int, GraphNode> get nodeMap {
    if (_nodeMap is EqualUnmodifiableMapView) return _nodeMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_nodeMap);
  }

  final Map<int, GraphEdge> _edgeMap;
  @override
  Map<int, GraphEdge> get edgeMap {
    if (_edgeMap is EqualUnmodifiableMapView) return _edgeMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_edgeMap);
  }

  final Map<String, bool> _labelVisibilityMap;
  @override
  Map<String, bool> get labelVisibilityMap {
    if (_labelVisibilityMap is EqualUnmodifiableMapView)
      return _labelVisibilityMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_labelVisibilityMap);
  }

  final Map<String, List<GraphNode>> _nodeToLabelMap;
  @override
  Map<String, List<GraphNode>> get nodeToLabelMap {
    if (_nodeToLabelMap is EqualUnmodifiableMapView) return _nodeToLabelMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_nodeToLabelMap);
  }

  @override
  final Graph? graph;

  @override
  String toString() {
    return 'RelationChartDataState(relationChartData: $relationChartData, labelMap: $labelMap, nodeMap: $nodeMap, edgeMap: $edgeMap, labelVisibilityMap: $labelVisibilityMap, nodeToLabelMap: $nodeToLabelMap, graph: $graph)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RelationChartDataStateImpl &&
            (identical(other.relationChartData, relationChartData) ||
                other.relationChartData == relationChartData) &&
            const DeepCollectionEquality().equals(other._labelMap, _labelMap) &&
            const DeepCollectionEquality().equals(other._nodeMap, _nodeMap) &&
            const DeepCollectionEquality().equals(other._edgeMap, _edgeMap) &&
            const DeepCollectionEquality()
                .equals(other._labelVisibilityMap, _labelVisibilityMap) &&
            const DeepCollectionEquality()
                .equals(other._nodeToLabelMap, _nodeToLabelMap) &&
            (identical(other.graph, graph) || other.graph == graph));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      relationChartData,
      const DeepCollectionEquality().hash(_labelMap),
      const DeepCollectionEquality().hash(_nodeMap),
      const DeepCollectionEquality().hash(_edgeMap),
      const DeepCollectionEquality().hash(_labelVisibilityMap),
      const DeepCollectionEquality().hash(_nodeToLabelMap),
      graph);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RelationChartDataStateImplCopyWith<_$RelationChartDataStateImpl>
      get copyWith => __$$RelationChartDataStateImplCopyWithImpl<
          _$RelationChartDataStateImpl>(this, _$identity);
}

abstract class _RelationChartDataState implements RelationChartDataState {
  const factory _RelationChartDataState(
      {required final RelationChartDataModel relationChartData,
      required final Map<String, LabelData> labelMap,
      required final Map<int, GraphNode> nodeMap,
      required final Map<int, GraphEdge> edgeMap,
      required final Map<String, bool> labelVisibilityMap,
      required final Map<String, List<GraphNode>> nodeToLabelMap,
      final Graph? graph}) = _$RelationChartDataStateImpl;

  @override
  RelationChartDataModel get relationChartData;
  @override
  Map<String, LabelData> get labelMap;
  @override
  Map<int, GraphNode> get nodeMap;
  @override
  Map<int, GraphEdge> get edgeMap;
  @override
  Map<String, bool> get labelVisibilityMap;
  @override
  Map<String, List<GraphNode>> get nodeToLabelMap;
  @override
  Graph? get graph;
  @override
  @JsonKey(ignore: true)
  _$$RelationChartDataStateImplCopyWith<_$RelationChartDataStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}
